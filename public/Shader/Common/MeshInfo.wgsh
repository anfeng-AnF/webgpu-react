const OPACITY_FLAG = 0x00000001;

//如果是PBR，后4位标志是否使用纹理
const MATERIAL_PBR = 0x00000002;
const BASE_COLOR_USE_TEXTURE = 0x00000004;
const METALLIC_USE_TEXTURE = 0x00000008;
const SPECULAR_USE_TEXTURE = 0x00000010;
const ROUGHNESS_USE_TEXTURE = 0x00000020;



// 网格信息 256 bytes
struct MeshInfo {
    // 模型矩阵 (64 bytes)
    modelMatrix: mat4x4<f32>,
    
    // 标志位 (4 bytes)
    flags: u32,

    // 预留空间 (188 bytes)
    reserved: array<f32, 44>,

    materialInfo: array<f32, 60> // 示例：共60个 float 填充 materialInfo，确保总大小为256字节（请根据实际需要调整）
};

@group(0) @binding(1) var<storage, read> meshInfos: array<MeshInfo>;

fn GetModelMatrix() -> mat4x4<f32> {
    return meshInfos[0].modelMatrix;
}

struct PBRMaterialInfo {
    modelMatrix: mat4x4<f32>,

    flags: u32,

    BaseColor: vec4<f32>,
    Metallic: f32,
    Specular: f32,
    Roughness: f32,
    PixelDepthOffset: f32,
}

fn GetPBRMaterialInfo() -> PBRMaterialInfo {
    var ret: PBRMaterialInfo;
    
    if (((meshInfos[0].flags & OPACITY_FLAG) == 0) || ((meshInfos[0].flags & MATERIAL_PBR) == 0)) {
        // 返回一个默认的无效材质信息
        ret.modelMatrix = meshInfos[0].modelMatrix;
        ret.flags = 0u;  // 清除所有标志位表示无效
        ret.BaseColor = vec4<f32>(1.0, 0.0, 1.0, 1.0);  // 紫红色表示错误
        ret.Metallic = 0.0;
        ret.Specular = 0.0;
        ret.Roughness = 1.0;
        ret.PixelDepthOffset = 0.0;
        return ret;
    }

    ret.modelMatrix = meshInfos[0].modelMatrix;
    ret.flags = meshInfos[0].flags;
    ret.BaseColor = vec4<f32>(meshInfos[0].reserved[0], meshInfos[0].reserved[1], meshInfos[0].reserved[2], meshInfos[0].reserved[3]);
    ret.Metallic = meshInfos[0].reserved[4];
    ret.Specular = meshInfos[0].reserved[5];
    ret.Roughness = meshInfos[0].reserved[6];
    ret.PixelDepthOffset = meshInfos[0].reserved[7];

    return ret;
}
